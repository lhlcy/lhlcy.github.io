<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端-lhl博客</title>

  <!-- keywords -->
  
    <meta name="keywords" content="前端">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lhl博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lhl博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lhl博客">
  
    <link rel="alternative" href="/atom.xml" title="lhl博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>
<script src="/js/Counter.js"></script>
  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/dad.jpeg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">lhl</a></h1>
		</hgroup>

		
		<p class="header-subtitle">有点小逗比</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/DOM-API/" style="font-size: 10px;">DOM ＡＰＩ</a> <a href="/tags/ajax请求简单认识/" style="font-size: 10px;">ajax请求简单认识</a> <a href="/tags/c33-动画-样式/" style="font-size: 10px;">c33 动画  样式</a> <a href="/tags/cookie-session-localStorage/" style="font-size: 10px;">cookie session localStorage</a> <a href="/tags/gulp-自动化打包工具/" style="font-size: 10px;">gulp 自动化打包工具</a> <a href="/tags/html5-标签/" style="font-size: 10px;">html5 标签</a> <a href="/tags/js-javascript-事件/" style="font-size: 10px;">js javascript 事件</a> <a href="/tags/响应式开发，Bootstrap/" style="font-size: 10px;">响应式开发，Bootstrap</a> <a href="/tags/移动端/" style="font-size: 10px;">移动端</a> <a href="/tags/页面优化看法/" style="font-size: 10px;">页面优化看法</a> <a href="/tags/DOM-三大家族/" style="font-size: 10px;">ＤＯＭ 三大家族</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">lhl</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/dad.jpeg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">lhl</h1>
			</hgroup>
			
			<p class="header-subtitle">有点小逗比</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-gulp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/05/gulp/" class="article-date">
  	<time datetime="2016-12-05T08:20:02.000Z" itemprop="datePublished">2016-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/05/gulp/">
        gulp
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gulp自动化打包"><a href="#gulp自动化打包" class="headerlink" title="gulp自动化打包"></a>gulp自动化打包</h1><h3 id="首先引入gulp文件require-39-gulp-39"><a href="#首先引入gulp文件require-39-gulp-39" class="headerlink" title="首先引入gulp文件require(&#39;gulp&#39;)"></a>首先引入gulp文件<code>require(&#39;gulp&#39;)</code></h3><blockquote>
<p>在gulp中，都是通过任务来实现的相对应的操作，task（）</p>
<p>第一个参数表示：当前任务的名称。想要执行这个任务只需要gulp</p>
<p>第二个参数表示：当前任务的依赖项，数组</p>
<p>第三个参数表示：是一个回调函数，任务代码就放在这个函数中</p>
</blockquote>
<h2 id="引入压缩模块"><a href="#引入压缩模块" class="headerlink" title="引入压缩模块"></a>引入压缩模块</h2><p><strong>js压缩（gulp-uglify）</strong></p>
<pre><code>gulp.task(&apos;js&apos;, function() {
// src 方法，用来获取到要操作的文件
gulp.src(&apos;src/index.js&apos;)
    .pipe(uglify())
    // pipe 让获取到的文件，沿着管道流动
    // dest 作用：指定文件的输入目录，会帮我们创建文件
    .pipe( gulp.dest(&apos;dist/&apos;) )
    // 告诉 browserSync 来同步文件的变化
    .pipe(browserSync.reload({stream: true}));
});
</code></pre><p><strong>es6的js压缩</strong></p>
<pre><code>babel-preset-es2015
gulp-babel(es6转es5语法)
gulp-uglify(文件压缩)

一定要先转换,再压缩
   const minjs = require(&apos;gulp-uglify&apos;);
   const es6toes5 = require(&apos;gulp-babel&apos;);
   gulp.task(&apos;minjs&apos;,()=&gt;{

       gulp.src([&apos;需要转换的js源文件&apos;],{base:&apos;src&apos;})
       .pipe(es6toes5({presets: [&apos;es2015&apos;]})) //表示将 js文件由es6转换成es5
       .pipe(minjs()) //再来压缩就不会报错了
       .pipe(gulp.dest(&apos;dist&apos;));

       console.log(&apos;js压缩完毕&apos;);
   });
</code></pre><p><strong>css压缩和并（gulp-cssnano，gulp-concat）</strong></p>
<pre><code>var cssnano = require(&apos;gulp-cssnano&apos;);
// 引入 concat 合并文件
var concat = require(&apos;gulp-concat&apos;);

gulp.task(&apos;css&apos;, function() {
gulp.src(&apos;src/css/*.css&apos;)
    // 合并文件
    .pipe(concat(&apos;all.css&apos;))
    // 压缩css
    .pipe(cssnano())
    .pipe(gulp.dest(&apos;dist/css&apos;))
    .pipe(browserSync.reload({stream: true}));
});
</code></pre><p><strong>将less转化成css(gulp -less)</strong></p>
<pre><code>// 引入 less 将less转化为css
var less = require(&apos;gulp-less&apos;);
gulp.task(&apos;less&apos;, function() {
    gulp.src(&apos;src/css/less-demo.less&apos;)
        .pipe(less())
        .pipe(gulp.dest(&apos;dist/css&apos;))
        .pipe(browserSync.reload({stream: true}));
});
</code></pre><p><strong>css的压缩及md5化</strong></p>
<pre><code>const rev = require(&apos;gulp-rev&apos;);
const mincss = require(&apos;gulp-clean-css&apos;);

gulp.task(&apos;mincssandcssmd5&apos;,()=&gt;{
gulp.src([&apos;./src/statics/css/*.css&apos;],{base:&apos;src&apos;})
.pipe(rev())
.pipe(mincss({compatibility: &apos;ie8&apos;}))
.pipe(gulp.dest(&apos;dist&apos;))
.pipe(rev.manifest())
.pipe(gulp.dest(&apos;./src/rev&apos;));

console.log(&apos;css压缩完毕&apos;);
});

替换html中引用了css的路径,并且本身Html也得压缩

const revCollector = require(&apos;gulp-rev-collector&apos;);  //替换静态资源文件名称插件
const htmlmin = require(&apos;gulp-htmlmin&apos;);

gulp.task(&apos;htmlminandreplaceurlname&apos;,()=&gt;{
gulp.src([&apos;./src/rev/*.json&apos;,&apos;./src/views/*.html&apos;],{base:&apos;src&apos;})
.pipe(revCollector())
.pipe(htmlmin({collapseWhitespace: true}))
.pipe(gulp.dest(&apos;dist&apos;));;
});
</code></pre><p><strong>引入html压缩（gulp-htmlmin）</strong></p>
<pre><code>var htmlmin = require(&apos;gulp-htmlmin&apos;);
gulp.task(&apos;html&apos;, function() {
    gulp.src(&apos;src/index.html&apos;)
        .pipe(htmlmin({collapseWhitespace: true, removeComments: true}))
        .pipe(gulp.dest(&apos;dist/&apos;))
        .pipe(browserSync.reload({stream: true}));
});
</code></pre><p><strong>图片压缩gulp-imagemin</strong></p>
<pre><code>var imagemin = require(&apos;gulp-imagemin&apos;)
gulp.task(&apos;img&apos;, function() {
    gulp.src(&apos;src/imgs/*.*&apos;)
        .pipe(imagemin())
        .pipe(gulp.dest(&apos;dist/img&apos;))
        .pipe(browserSync.reload({stream: true}));
});
</code></pre><p><strong>引入 browser-sync 浏览器同步刷新</strong></p>
<pre><code>var browserSync = require(&apos;browser-sync&apos;).create();

gulp.task(&apos;bs&apos;, function() {
    browserSync.init({
            // 指定服务器的根目录
      server: {
          baseDir: &apos;./dist&apos;
      }
  });
});
</code></pre><p><strong>利用watch来监控</strong></p>
<pre><code>gulp.task(&apos;watch&apos;, [&apos;bs&apos;], function() {

    // 监视文件的变化
    // 第一个参数u：表示要监视的文件
    // 第二个参数u：表示监视到变化后，要执行的任务
    gulp.watch(&apos;src/index.html&apos;, [&apos;html&apos;]);
    gulp.watch(&apos;src/index.js&apos;, [&apos;js&apos;])
    gulp.watch(&apos;src/css/*.css&apos;, [&apos;css&apos;])
    gulp.watch(&apos;src/css/*.less&apos;, [&apos;less&apos;])
});
</code></pre><p><strong>默认执行 default 任务</strong></p>
<p>gulp.task(‘default’, [‘js’, ‘css’, ‘less’, ‘html’, ‘watch’])</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gulp-自动化打包工具/">gulp 自动化打包工具</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/12/05/gulp/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="gulp">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-cookie-session-localStorage区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/29/cookie-session-localStorage区别/" class="article-date">
  	<time datetime="2016-08-29T13:28:23.000Z" itemprop="datePublished">2016-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/29/cookie-session-localStorage区别/">
        cookie,session,localStorage区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="cookie-，session-和localStorage的区别"><a href="#cookie-，session-和localStorage的区别" class="headerlink" title="cookie ，session 和localStorage的区别"></a>cookie ，session 和localStorage的区别</h1><blockquote>
<p>cookie:名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围,如果不设过期时间那么，那么cookie表示是在会话时间，当浏览器关闭就没有了，并不会保存到内存中.单如果设了过期时，浏览器会把cookie保存到硬盘中。</p>
<p>session:sessio是一种服务器机制，当要创建一个session时候，服务器会先创建一个session id的标识。用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</p>
<h3 id="实际上大多数的应用都是用-Cookie-来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在-Cookie-里面记录一个Session-ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。但是如果cookie被禁用了，那么可以利用URL后面添加参数的方式来告诉服务器识别用户。"><a href="#实际上大多数的应用都是用-Cookie-来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在-Cookie-里面记录一个Session-ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。但是如果cookie被禁用了，那么可以利用URL后面添加参数的方式来告诉服务器识别用户。" class="headerlink" title="实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。但是如果cookie被禁用了，那么可以利用URL后面添加参数的方式来告诉服务器识别用户。"></a>实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。但是如果cookie被禁用了，那么可以利用URL后面添加参数的方式来告诉服务器识别用户。</h3><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ul>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</li>
<li>session会在一定时间来保存在服务器上。当访问增多了，会占用服务器的性能。考虑到减轻服务器性能方面，应当使用cookie.</li>
<li>cookie 保存的数据不能超过4k，很多浏览器都会限制一个占点最多保存20个cookie。</li>
<li>所以建议： 登录信息一般存放在session,其他信息保留咋cookie</li>
<li>session 保存在服务器中，客户端不知道其中的信息，cookie保存在客户端，服务器能够知道其中的信息。</li>
<li>session中保存的是对象，cookie保存是字符串</li>
<li>session不能区分路径，同一个用户在一个网站期间，所以的session在任何一个地方都可以访问到。而如果设置参数，那么同一个网站不同路径下cookie互相访问不到的<h2 id="web-storage和cookie"><a href="#web-storage和cookie" class="headerlink" title="web storage和cookie"></a>web storage和cookie</h2>sessionStroge 和localStorag，cookie都是在浏览器端存储数据的，其中sessionStoage是在同源的同窗口中。始终存在的数据。就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。而localStorage是始终保存在浏览器中。除非自己删除。<h4 id="web-Storage带了好处"><a href="#web-Storage带了好处" class="headerlink" title="web Storage带了好处"></a>web Storage带了好处</h4></li>
</ul>
<ol>
<li>减少流浪：一旦数据保存在本地以后，就可以避免在向服务器请求数据，因此减少不必要数据请求。减少数据不必要的来回的传递。</li>
<li>快速的显示数据;性能好，从本地读数据比通过服务器获得快。本地数据可以即时获得。再加上页面本身也可以有缓存，页面可以加快显示速度。</li>
<li>临时存储：有很多数据只需要用户浏页面期间使用，关闭窗口后数据就丢失，这时候用sessiStorage很方便。</li>
</ol>
</blockquote>
<p><strong>sessionStorage 、localStorage 和 cookie 之间的区别</strong></p>
<pre><code>共同点：都是保存在浏览器端，且同源的。
区别：
    1.cookie数据始终子啊同源的http携带，cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
    2.存储大小限制也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
    3 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
    4 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
    5
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cookie-session-localStorage/">cookie session localStorage</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/08/29/cookie-session-localStorage区别/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="cookie,session,localStorage区别">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-重绘重排" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/20/重绘重排/" class="article-date">
  	<time datetime="2016-05-20T00:39:56.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/重绘重排/">
        &#39;重绘重排&#39;
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h2><h3 id="DOM树和渲染树："><a href="#DOM树和渲染树：" class="headerlink" title="DOM树和渲染树："></a>DOM树和渲染树：</h3><pre><code>DOM树表示页面的结构 
 渲染树表示DOM节点在页面如何显示
</code></pre><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><p> 当DOM的变化影响了元素的几何属性的时候，浏览器需要我们重新的计算元素元素的几何属性，同样的其他元素的几何属性也会受到影响，这是时候浏览器就会重新构造渲染树 就叫重排</p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p> 当完成重排以后，浏览器会重新绘制受到影响的部分，这过程叫重绘</p>
<p>（一般流布局对渲染树一般只需要变了一次就可以，但是一些table元素除外，所以我们之前会放弃table布局方式）</p>
<h3 id="导致重绘重排的原因"><a href="#导致重绘重排的原因" class="headerlink" title="导致重绘重排的原因"></a>导致重绘重排的原因</h3><p>（1）添加和删除可见的DOM元素的时候<br>（2）元素的位置改变<br>（3）元素的尺寸大小改变<br>（4）元素的内容改变（比如文本被图片替换的时候）<br>（5）页面的初始化渲染（无法改变）<br>（6）浏览器的窗口尺寸改变</p>
<h3 id="渲染树的队列和刷新"><a href="#渲染树的队列和刷新" class="headerlink" title="渲染树的队列和刷新"></a>渲染树的队列和刷新</h3><pre><code>一般我们设置样式比如
var ele = document.getElementById(&apos;myDiv&apos;);
ele.style.borderLeft = &apos;1px&apos;;
ele.style.borderRight = &apos;2px&apos;;
ele.style.padding = &apos;5px&apos;;
</code></pre><p>这时候浏览器一般会选择队列模式，经常浏览器会现将保存，后面一次执行<br>但是当我们如果中间如果有获取布局信息代码的时候这时候我们就会强制将队列执行刷新页面这时候就会几次渲染页面导致多次重绘重排 （比如）<br>offsetTop, offsetLeft, offsetWidth, offsetHeight<br>scrollTop, scrollLeft, scrollWidth, scrollHeight<br>clientTop, clientLeft, clientWidth, clientHeight<br>所以一般情况下最好不要将获取信息放在中间</p>
<h3 id="fragment元素"><a href="#fragment元素" class="headerlink" title="fragment元素"></a>fragment元素</h3><h4 id="当我们要添加多个不同元素的时候可能我们要多次的操作DOM元素，这样就可能会引起多次的重绘与重排现象那么这时候我可以借用fragment元素-利用createDocumentFragment因为fragment默认是不占位是为虚拟的比如：要添加两个li"><a href="#当我们要添加多个不同元素的时候可能我们要多次的操作DOM元素，这样就可能会引起多次的重绘与重排现象那么这时候我可以借用fragment元素-利用createDocumentFragment因为fragment默认是不占位是为虚拟的比如：要添加两个li" class="headerlink" title="当我们要添加多个不同元素的时候可能我们要多次的操作DOM元素，这样就可能会引起多次的重绘与重排现象那么这时候我可以借用fragment元素 利用createDocumentFragment因为fragment默认是不占位是为虚拟的比如：要添加两个li"></a>当我们要添加多个不同元素的时候可能我们要多次的操作DOM元素，这样就可能会引起多次的重绘与重排现象那么这时候我可以借用fragment元素 利用createDocumentFragment因为fragment默认是不占位是为虚拟的比如：要添加两个li</h4><pre><code>    &lt;ul id=&apos;fruit&apos;&gt;
      &lt;li&gt; apple &lt;/li&gt;
      &lt;li&gt; orange &lt;/li&gt;
    &lt;/ul&gt;
var fragment = document.createDocumentFragment();
var li = document.createElement(&apos;li&apos;);
li.innerHTML = &apos;apple&apos;;
fragment.appendChild(li);
var li = document.createElement(&apos;li&apos;);
li.innerHTML = &apos;watermelon&apos;;
fragment.appendChild(li);
document.getElementById(&apos;fruit&apos;).appendChild(fragment);
</code></pre><h3 id="建议处理重绘重排"><a href="#建议处理重绘重排" class="headerlink" title="建议处理重绘重排"></a>建议处理重绘重排</h3><p>（1）使用绝对定位在页面上的元素，让其脱离文档流<br>（2）让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。<br>（3）当动画结束时恢复定位，从而只会下移一次文档的其他元素</p>
<h3 id="总结：（1）尽量不要在布局信息改变时做查询"><a href="#总结：（1）尽量不要在布局信息改变时做查询" class="headerlink" title="总结：（1）尽量不要在布局信息改变时做查询"></a>总结：（1）尽量不要在布局信息改变时做查询</h3><p>（2）同一个DOM的多个属性改变可以写在一起（减少DOM访问，同时把强制渲染队列刷新的风险降为0）<br>（3）如果要批量添加DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排<br>将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位 </p>
<h4 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h4><p><a href="http://web.jobbole.com/83164/" target="_blank" rel="external">重绘重排</a>    </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/页面优化看法/">页面优化看法</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/05/20/重绘重排/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="&#39;重绘重排&#39;">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-响应式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/响应式/" class="article-date">
  	<time datetime="2016-05-02T13:37:07.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/响应式/">
        响应式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h1><p><strong>什么是响应式开发</strong>：可以响应不同的布局。<br>a)    在移动互联日益成熟的时候，桌面浏览器上开发的网页已经不能满足移动端的设备的展示和阅读<br>b)    之前，通常的做法是对移动端单独开发一套特定的版本<br>c)    但是，如果移动终端设备起来越多的时候赋发成本太大，是因为需要做所有屏幕的适配<br>d)    响应式开发的目的就是:一个网站能够兼容多种终端<br>e)    在新建的网站上一般都会使用响应式开发<br>f)    移动web开发和响应式开发是必须具备的技能<br>g)    演示响应者页面<br>为什么说是大势所趋呢？<br>现在的移动设备屏幕越来越大。<br>越来越多的设计师也采用了这种设计。<br>在新建站的一些网站现在普遍采用的响应式开发。<br><img src="http://i.imgur.com/iwoXZpa.png" alt="2. 响应式开发和移动web开发的区别"><br><strong>响应式开发的原理</strong>：媒体查询：</p>
<pre><code>a)    查询媒介，查询到当前屏幕的宽度，针对不同的屏幕宽度设置不同的样式来适应不同屏幕。
    当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。
    简单说，你可以设置 不同屏幕下面的不同的样式，达到适配不同的屏幕的目的。

b)    实现方式：通过查询screen的宽度来指定某个宽度区间的网页布局。 
    超小屏幕    （移动设备）768px以下 
    小屏设备    768px-992px         768 &lt;= w &lt;992
    中等屏幕    992px-1200px      992 =&lt; w &lt;1200
    宽屏设备    1200px以上      &gt;=1200
</code></pre><p><strong>媒体查询的基本实现方式</strong>：常用属性设置: <a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html" target="_blank" rel="external">http://www.runoob.com/cssref/css3-pr-mediaquery.html</a></p>
<p>a)    CSS 语法<br>    @media mediatype and|not|only (media feature) {<br>        CSS-Code;<br>    }</p>
<p><strong>你也可以针对不同的媒体使用不同</strong> stylesheets :<br>    <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"></p>
<p>b)    媒体类型</p>
<pre><code>值                描述
all                用于所有设备
print            用于打印机和打印预览
screen            用于电脑屏幕，平板电脑，智能手机等。
speech            应用于屏幕阅读器等发声设备
</code></pre><p>c)    媒体功能</p>
<pre><code>值                        描述
device-height            定义输出设备的屏幕可见高度。
device-width                定义输出设备的屏幕可见宽度。
max-device-height        定义输出设备的屏幕可见的最大高度。
max-device-width            定义输出设备的屏幕最大可见宽度。
min-device-width            定义输出设备的屏幕最小可见宽度。
min-device-height        定义输出设备的屏幕的最小可见高度。
max-height                定义输出设备中的页面最大可见区域高度。
max-width                定义输出设备中的页面最大可见区域宽度。
min-height                定义输出设备中的页面最小可见区域高度。
min-width                定义输出设备中的页面最小可见区域宽度。
</code></pre><h2 id="Bootstrap框架"><a href="#Bootstrap框架" class="headerlink" title="Bootstrap框架"></a>Bootstrap框架</h2><p><a href="http://www.bootcss.com/" target="_blank" rel="external">Bootstrap</a>简介：当前最流行的前端UI框架(有预制界面组件), Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目</p>
<pre><code>1. Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷

2. Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件
</code></pre><p>为什么 使用Bootstrap:</p>
<pre><code>1. 有自己的生态圈，不断的更新迭代
2. 提供一套简洁，直观，强悍的组件
3. 标准化的html+css编码规范
4. 让开发更简单，提高了开发效率
5. 可以进行自定义扩展
</code></pre><p>BootStrap的版本了解</p>
<pre><code>1. 2.x.x:兼容性好  / 代码不够简洁，功能不够完善
2. 3.x.x:稳定性好,放弃了IE6-IE7,对IE8的支持一般 /偏向于响应式布局开发，移动设备优先的web项目开发
3. 4.x.x:测试阶段，偏向于响应式，移动设备
</code></pre><p><strong>框架使用</strong></p>
<ol>
<li>模板</li>
<li>全局样式</li>
<li>容器<ol>
<li>.container</li>
<li>.container-fulid        100%</li>
</ol>
</li>
<li>栅格系统<ol>
<li>row </li>
<li>column<br><img src="http://i.imgur.com/Y6pehpM.png" alt="栅格系统"><ul>
<li>栅格系统的意义：移动设备和桌面屏幕：它可以规范在不同尺寸的屏幕下，当前的列占据的宽度。或者说一行可以放置几个列。</li>
<li>栅格系统是往上兼容的：意味着小屏幕上的效果在大屏幕上也是可以正常显示的人，但是大屏幕上的设置在小屏幕上却无法正常显示。</li>
<li>Row可以再次嵌套在列中。如果不能填满整列，则默认从左排列，如果超出，则换行展示</li>
</ul>
</li>
<li>嵌套列</li>
<li>列偏移</li>
</ol>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/响应式开发，Bootstrap/">响应式开发，Bootstrap</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/05/02/响应式/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="响应式">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="dom-API" class="article article-type-dom" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/05/API/" class="article-date">
  	<time datetime="2016-04-05T08:54:56.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/API/">
        API
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h1><p>##节点##</p>
<pre><code>元素节点 标签

属性节点 元素属性

文本节点 元素中内容

注释节点    注释
</code></pre><p>##节点属性##</p>
<pre><code>nodeName
    - 元素节点    与标签名相同
    - 属性节点    属性的名称
    - 文本节点    #text
    - 文档节点    #document
    - 注释节点

nodeType
    - 元素    1
    - 属性    2
    - 文本    3
    - 注释    8
    - 文档    9
    - 文档类型节点    10
    - 文档片段节点    11

nodeValue
    - 元素节点    undefined或null
    - 文本节点    文本自身
    - 属性节点    属性的值
</code></pre><p>##获取节点##</p>
<pre><code>getElementById 根据Id 得到一个元素

getElementsByClassName 根据类名 得到一个数组  ie6/7/8有兼容性问题
    封装兼容性思路:取出所有的盒子,并判断类名
var dom = document.body.getElementsByTagName(&quot;*&quot;);

getElementsByName name属性

getElementsByTagName 根据标签 得到一个数组

其他:
document.head
document.body
document.title  浏览器标题处显示的内容
document.documentElement(html根节点);
</code></pre><h3 id="document的属性"><a href="#document的属性" class="headerlink" title="document的属性"></a>document的属性</h3><pre><code>document.title
document.bgColor
document.linkColor
document.alinkColor
document.vlinkColor
document.URL
document.fileCreatedDate
document.fileModifiedDate
document.fileSize
document.cookie
document.charset
</code></pre><p>##遍历节点方法##</p>
<pre><code>children    不是标准的DOM属性,但是得到所有浏览器支持,而且只会获得标签节点

childNodes  是标准的DOM属性,返回一个数组
    - 高版本浏览器会计算空白文本节点

firstChild    第一个节点

firstElementChild    第一个节点

lastChild    最后一个节点

lastElementChild  最后一个节点

parentNode 返回父节点

nextSibling   下一个兄弟节点     会获得除标签以外的文本节点,IE8及之前的所有浏览器都支持,
    低版本IE会忽略空白文本节点
    - 需排除空白文本节点    属性值为3
    - x.nodeType != 1
    - x &amp;&amp; x.nodeType != 1

nextElementSibling        IE不支持,会报错 只会获得元素节点

    ?_? var aim = d.nextElementSibling || d.nextSibling;返回了一些奇怪的东西!

previousSibling  上一个元素

previousElementSibling    上一个元素   IE不支持
</code></pre><p>##DOM操作## </p>
<pre><code>    - 三步：创建、赋值、插入。
    - 操作是在子节点位置

obj.style的方式:
getAttribute() 获得元素节点的属性值
setAttribute() 设置元素节点的属性值

添加多个属性的方式:添加类名

获取某个属性的值: window.getComputedStyle(obj,null)[attr];
    obj.currentStyle[attr] IE支持的

- inputs[i].value = &quot;a&quot;+i;                    // 属性对象方式, 写入内存

- inputs[i].setAttribute(&quot;value&quot;,&quot;a&quot;+i);        // 元素对象方式, 写入文件
- inputs[i].getAttribute(&quot;value&quot;)

innerHTML:无兼容性问题,赋值的innerHTML里面如果有标签,会解析

innerText:IE8及以前的浏览器版本支持,但是低版本的火狐42不支持,仅支持textContent,而IE8及以前的浏览器又不支持textContent,高版本的都支持这两个属性.
    - 兼容性方法:
    function set(ele,value) {
        if(typeof ele.innerText == &quot;string&quot;) {
            ele.innerText = value;
        }else {
            ele.textContent = value;
        }
    }

createElement(&quot;p&quot;) 创建元素节点
    - var btn = document.createElement(&quot;input&quot;);
    - btn.setAttribute(&quot;onclick&quot;, &quot;javascript:alert(&apos;This is a text!&apos;);&quot;); 
    - body.appendChild(btn);     
    - IE7 创建表格必须有表头

createTextNode(&quot; &quot;) 创建文本节点
    -  var te = document.createTextNode(&quot;I Love JavaScript!&quot;);
    - ele.appendChild(te);

appendChild() 在某节点的子节点后插入节点
    - 还有剪切功能.

insertBefore() 之前
    - var otest = document.getElementById(&quot;test&quot;);  
    - var a= document.createElement(&quot;li&quot;);
    - a.innerHTML=&quot;PHP&quot;;
    - otest.insertBefore(a,otest.lastChild);
    - 还有剪切功能.

removeChild() 删除一个子节点
    - 从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。
    - 1. 删除该节点的内容，先要获取子节点。
    - 2. 然后使用循环遍历每个子节点。
    - 3. 使用removeChild()删除节点。
    - while(content.firstChild) {
          content.removeChild(content.firstChild);}

replaceChild() 替换一个子节点
    - 只有父结点才能调用  replaceChild(newnode,oldnode).这个方法.
        所以，要想替换当前结点的内容或者属性，那么首先得获得父节点，才可以操作，
        这就是为什么 oldnode.parentNode.replaceChild(newnode,oldnode); 这句代码的写法。。
    - old.parentNode.replaceChild(new,old); 
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM-API/">DOM ＡＰＩ</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/04/05/API/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="API">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ajax请求" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/12/ajax请求/" class="article-date">
  	<time datetime="2016-03-12T10:39:56.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/ajax请求/">
        ajax
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><pre><code>Asynchronous Javascript And Xml
</code></pre><p><strong>AJAX不是一门语言, 而是对现有技术的综合利用. 本质是在HTTP协议的基础上以异步的方式与服务器进行通信</strong></p>
<p><strong>异步</strong> 指某段程序执行时 <strong>不会阻塞</strong> 其他程序执行, 其表现形式为程序的执行顺序 <strong>不依赖程序本身的书写顺序</strong> ,相反则为同步.</p>
<p><strong>文件传输协议</strong></p>
<pre><code>HTTP    超文本传输协议
FTP        文件传输协议
SMTP    简单邮件传输协议等
</code></pre><p><strong>XMLHttpRequest</strong> 浏览器内建对象, 用于在 <strong>后台</strong> 与服务器通信, 由此我们便可实现对网页的<strong>部分刷新</strong></p>
<h3 id="aphache环境配置"><a href="#aphache环境配置" class="headerlink" title="aphache环境配置"></a>aphache环境配置</h3><ol>
<li><p>配置网站根目录<br> 打开**\bin\apache\Apache2.2.21\conf\httpd.conf<br> 查找并修改 DocumentRoot<br> 查找并修改 <directory "d:="" wamp="" www="" "=""> </directory></p>
</li>
<li><p>配置虚拟主机<br> 打开**\bin\apache\Apache2.2.21\conf\httpd.conf<br> 找到# Virtual hosts<br> Include conf/extra/httpd-vhosts.conf     取消注释</p>
<p> 配置conf/extra/httpd-vhosts.conf文件的地址指向</p>
<pre><code>DocumentRoot
ServerName
ServerAlias
</code></pre></li>
<li><p>配置DNS<br> 修改本机hosts文件<br> 注意修改hosts文件权限</p>
</li>
</ol>
<hr>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><pre><code>XML是一种标记语言, 类似html, 宗旨是用来传输数据. 独立于语言, 跨平台

&lt;?xml version=&quot;1.0&quot; charset=&quot;utf-8&quot;?&gt;
&lt;root&gt;
    &lt;school&gt;
        &lt;class&gt;
            &lt;student&gt;
                &lt;name&gt;hh&lt;/name&gt;
            &lt;/student&gt;
        &lt;/class&gt;
    &lt;/school&gt;
&lt;/root&gt;
</code></pre><p><strong>语法规则</strong></p>
<pre><code>1. 必须有一个根元素

2. 标签开头不可有空格、不可以数字或.开头、大小写敏感

3. 属性双引号（浏览器自动修正成双引号了）

4. 特殊符号要使用实体

5. 解析过于复杂并且体积较大。解析--DOM操作与html类似
</code></pre><hr>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><pre><code>JavaScript Objest Notation 另一种轻量级的文本数据交换格式, 独立于语言, 跨平台

var    school = {
    &quot;class&quot;: {
        &quot;student&quot;: {
            &quot;name&quot;:&apos;hh&apos;
        }
    }
}
</code></pre><p><strong>特点</strong></p>
<pre><code>1. 数据在键值对中
2. 数据由逗号分隔
3. 花括号对象/方括号数组
4. 使用双引号
</code></pre><p><strong>解析</strong></p>
<pre><code>    JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取

1. eval()

2. JSON内建对象
    1. JSON.parse()            从字符串解析出json对象
    2. JSON.stringify()        从json对象解析为字符串

3. php方法
    1. json_encode()        对变量进行 JSON 编码，返回 value 值的 JSON 形式
    2. json_decode()        将json字符串转化为php变量
</code></pre><hr>
<h2 id="AJAX编程"><a href="#AJAX编程" class="headerlink" title="AJAX编程"></a>AJAX编程</h2><p><img src="http://i.imgur.com/p0WPOo9.jpg" alt="实现流程"></p>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><pre><code>1. 实例化                new HMLHttpRequest()
        兼容处理: IE5、IE6中不支持XMLHttpRequest
        IE5、IE6中使用 ActiveObject(&quot;Microsoft.XMLHTTP&quot;);

2. 设置请求行                .open(&apos;get&apos;,&apos;index.php&apos;)

3. post方式需设置请求头    .setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;)

4. 发送请求请求主体        .send(data)

5. 监听服务器响应            .onreadystatechange = fn
    1. 获取状态行                .status==200/.readystate=4/.statusText=OK
    2. 获取响应头                .getResponseHeader()/getAllResponseHeaders()
    3. 响应主体                .responseText/responseXML    (根据响应头的类型选取)
</code></pre><p><strong>get/post的差异</strong></p>
<pre><code>1. get没有请求主体. 使用null
2. get可以通过请求url上添加请求参数
3. post可以通过xhr.send(&apos;name=itcast&amp;age=10&apos;)添加参数
4. post需要设置xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;)
5. get效率更好 常用
6. get大小限制约4k, post没有限制    (如何获取复杂数据)
</code></pre><p><strong>请求报文</strong></p>
<pre><code>请求报文行
    由 请求方式 / url / 协议版本 构成    
报文头
    host:请求的主机
    accept:接受的文档MIME类型
    user-Agent:客户端信息
    refer:从哪个url跳转的
</code></pre><p><strong>响应报文</strong></p>
<pre><code>.responseText
.responseXML
.status
.readystate
.statusText

.getResponseHeader()
.getAllResponseHeaders()
</code></pre><p><strong>事件</strong></p>
<pre><code>.onreadystatechande
.readyState
    0     open尚未调用
    1    已调用
    2    接收到头部信息
    3    接收到响应主体
    4    响应完成 
</code></pre><p><strong>等等</strong></p>
<pre><code>设置超时
使用FormData()
文件上传
跨越资源共享
上传时度
</code></pre><p><strong>jQuery框架的ajax</strong></p>
<pre><code>jQuery: $.ajax({
    type:&apos;get&apos;,
    data:&apos;&apos;,
    dataType,        jsonp用于跨域
    url:&apos;&apos;,
    beforeSend:fn(){}    发送前动作
    success:fn(){}        响应成功动作
    error:fn(){}        错误响应式调用
    complete:fn(){}        响应完成动作 不论成功还是失败

})

jQuery.get(url, [data], [callback], [type])
jQuery.post(url, [data], [callback], [type])

$.serialize()        将表格内容序列化为字符串, 用于ajax请求
$.serializeArray()    序列化为json数据结构, 需要另外进行解析
</code></pre><hr>
<p><strong>模板引擎</strong></p>
<pre><code>    其本质是利用正则表达式，替换模板当中预先定义好的标签。 exec

    方便对获得的大量复杂数据的渲染

artTemplate        https://github.com/aui/artTemplate

    1. 引入template-native.js

    2. &lt;% 与  %&gt; 符号包裹起来的语句则为模板的逻辑表达式

    3. &lt;%= content %&gt;为输出表达式

        var html = template(&apos;tempId&apos;,obj)    
        使用的是传入对象的属性, 数组需进行包装

JsRender
baiduTemplate        http://tangram.baidu.com/BaiduTemplate/
Mustache
Hanldebars            http://handlebarsjs.com/
velocity.js            https://github.com/shepherdwind/velocity.js/
</code></pre><hr>
<h3 id="接口化开发"><a href="#接口化开发" class="headerlink" title="接口化开发"></a>接口化开发</h3><pre><code>1. 请求地址即所谓的接口

2. 接口化开发，是指一个接口对应一个功能，并且严格约束了请求参数和响应结果的格式

3. 这样前后端在开发过程中，可以减少不必要的讨论，从而并行开发，可以极大的提升开发效率

4. 另外一个好处，当网站进行改版后，服务端接口只需要进行微调。
</code></pre><hr>
<h3 id="同源策略与跨域"><a href="#同源策略与跨域" class="headerlink" title="同源策略与跨域"></a>同源策略与跨域</h3><pre><code>同源策略(域名/协议/端口完全相同)是浏览器的一种安全策略, 也就是浏览器默认不允许跨域

1. 跨域和同源机制是浏览器的行为: 默认会阻止跨域请求
2. 跨域是指: 协议, 域名或者端口不同
3. 本质利用了src的天然跨域特性
</code></pre><p><strong>跨域解决方案</strong></p>
<pre><code>JSONP      json with padding 
    (jsonp跨域与异步对象, 没有任何关系, 不是使用异步对象来做的)
    本质利用了script标签src属性具有可跨域的特性

    由服务端返回一个预先定义好的Javascript函数的调用

    并且把服务器数据以函数参数形式传递过来, 前后端配合完成/只能以get方式请求 
1. 页面预先有定义函数
    &lt;script type=&quot;text/javascript&quot;&gt;
        function dosomething(jsondata){
            //处理获得的json数据
        }
    &lt;/script&gt;

2. 请求中指定需要执行的函数名
    &lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;

3. php中得到函数名, 并将数据拼接为函数调用形式, 返回到页面中即形成调用
    &lt;?php
    $callback = $_GET[&apos;callback&apos;];//得到回调函数名
    $data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据
    echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出
    ?&gt;

    1. jQuery 的$.ajax() 方法当中集成了JSONP的实现，可以非常方便的实现跨域数据的访问。

    2. dataType: &apos;jsonp&apos; 设置dataType值为jsonp即开启跨域访问

    3. jsonp 可以指定服务端接收的参数的“key”值，默认为callback

    4. jsonpCallback 可以指定相应的回调函数，默认自动生成
            对传回的数据进行分解, 使用



document.domain + iframe
    顶级域名相同的可以通过domain.name来解决，即同时设置 domain.name = 顶级域名（如example.com）

window.name + iframe

location.hash + iframe

window.postMessage
    window.postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源
</code></pre><hr>
<pre><code>CORS    未来标准

    CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

    整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

    因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
</code></pre><p><strong>要么万人之上的深度, 要么万人玩不来的技能!</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax请求简单认识/">ajax请求简单认识</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/03/12/ajax请求/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="ajax">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-移动web开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/19/移动web开发/" class="article-date">
  	<time datetime="2016-02-19T13:50:28.000Z" itemprop="datePublished">2016-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/19/移动web开发/">
        移动web开发
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="移动web开发"><a href="#移动web开发" class="headerlink" title="移动web开发"></a>移动web开发</h1><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><pre><code>其实流式布局就是百分比布局，通过设置宽度百分比来自适应屏幕宽度。
</code></pre><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><pre><code>在移动端用来承载网页的区域，就是我们的视觉窗口（视口），这个区域可以设置宽高，缩放或者设置是否允许用户缩放
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;
</code></pre><p><strong>设置成标准的移动开发页面</strong></p>
<pre><code>用meta标签把viewport的宽度设为device-width，同时initial-scale=1，user-scalable = 0就构建了一个标准的移动web页面 
</code></pre><p><strong>高清屏的问题</strong></p>
<pre><code>在高清屏中会用两个或多个物理像素来显示实际的1px图片内容

解决方案，采用压缩图标尺寸的方式来解决。 
    如果是Img使用直接设置宽高的方式来压缩。
    如果是背景使用的是设置background-size的方式来压缩。
</code></pre><h2 id="移动端事件"><a href="#移动端事件" class="headerlink" title="移动端事件"></a>移动端事件</h2><p><strong>触摸事件</strong></p>
<pre><code>Touch
touchstart：当手指触碰屏幕时候发生。不管当前有多少只手指

touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，
会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动

touchend：当手指离开屏幕时触发

touchcancel：系统停止跟踪触摸时候会触发。
例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用
触摸事件的响应顺序
1、ontouchstart
2、ontouchmove
3、ontouchend

4、onclick  300ms延时
</code></pre><p><strong>动画及过度事件</strong></p>
<pre><code>transitionEnd(webkitTransitionEnd)        过渡结束后触发。

animationEnd(webkitAnimationEnd)        动画结束后触发
</code></pre><p><strong>Gesture事件</strong></p>
<pre><code>gesturestart
当一个手指触摸屏幕之后，第二个手指再触摸屏幕时触发。
gesturechange
当上面的事件触发后立即触发。
gestureend
第二根手指离开屏幕时触发，之后将不会再次触发gesturechange。

在event当中会返回另外两个参数
scale 根据两个手指的滑动距离计算的缩放比例 初始1
rotation根据两个手指的滑动距离计算的旋转角度 初始 0
</code></pre><p><strong>事件对象</strong></p>
<pre><code>originalEvent  是jquery 封装的事件。
targetTouches 目标元素的所有当前触摸 
changedTouches 页面上最新更改的所有触摸 
touches 页面上的所有触摸

注意：在touchend事件的时候event只会记录changedtouches
</code></pre><h2 id="常见css属性"><a href="#常见css属性" class="headerlink" title="常见css属性"></a>常见css属性</h2><pre><code>全屏单页面布局    html,body{ height: 100%; }

点击高亮效果        -webkit-tap-highlight-color:transparent;/*清除点击高亮效果*/

边框盒子            -webkit-box-sizing: border-box; box-sizing: border-box;

Input清除默认的样式 -webkit-appearance: none;

最小宽度和最大宽度的限制 
    max-width: 640px;  /*在行业当中的移动端的设计图一般使用的是640px*/
    min-width: 300px;  /*在移动设备当中现在最小的尺寸320px*/

    适用：图片比较多的首页，门户，电商 等。
    作用  保证页面在尺寸比较大的设备当中保证页面的效果也就是清新度
    保证页面在小尺寸的设备当中有较好的布局效果。

键盘适配 tel search email

移动事件：在移动端是利用transform来做定位。
    1. 使用 margin/top 修改會觸發 reflow，拖慢速度。
    2. absolute 和 fixed 的元素的 reflow 不會牽動整體，但依舊不如 transform 只需要 repaint。
    3. 而 translate 和 translate3d 的區別則在於硬件加速。

按钮优化方式：padding加背景裁切clip：content
</code></pre><h2 id="事件封装"><a href="#事件封装" class="headerlink" title="事件封装"></a>事件封装</h2><p>Tap：<br>    由于在移动端click会有300ms左右的延时，为了响应速度更快移动端框架一般会封装一个加tap的事件，原理：利用touch事件当没有滑动过并且响应时间在一定的时间内（比click快）那么这样的一个过程就是一个tap事件。</p>
<p>Swipe：<br>    在移动端有手势事件，也是一些移动端框架封装出来的那么这种事件也是touch事件开始的位置和结束的位置来判断手势的情况。是向下滑还是向右滑，是向下滑还是向上滑。</p>
<p><strong>移动端框架</strong></p>
<pre><code>Zepto： 轻量级、依赖自选插件
</code></pre><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><strong>首页的适用场景</strong> </p>
<pre><code>门户电商的首页   而且内容比较丰富  
</code></pre><p><strong>分类页面的使用场景</strong></p>
<pre><code>是单页面  全屏的布局当中会使用
异步的交互  ajax    web app 的开发模式当中会使用到
Web  app  网页程序 网页应用
移动web页面优点： 跨平台  android  ios

Hybird app 现在流行起来的  混合应用  开发模式 
套用  嵌入 移动web页面的 应用所有的移动页面都可以

Native  app 原生应用
</code></pre><p><strong>购物车页面</strong></p>
<pre><code>任何地方都可以用到这样的布局。
</code></pre><p>*<img src="http://i.imgur.com/6vJajfW.png" alt="两栏自适应布局原理"></p>
<pre><code>那么当文本在另一个容器当中，容器是overflow：hidden的时候。那么这个时候这个盒子就变成了一个绝缘的盒子，不去影响任何外部的元素并且内容使用剩余的宽度。

这样也可是做一个自适应的两栏布局方式。
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动端/">移动端</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2016/02/19/移动web开发/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="移动web开发">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-h5总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/h5总结/" class="article-date">
  	<time datetime="2015-12-05T08:44:12.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/h5总结/">
        h5总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><pre><code>新一代web富客户端整体解决方案, 能做很好看的网页 PC,APP,weiChat端应用程序 一些游戏 

声明格式:&lt;!doctype html&gt;
</code></pre><p><strong>语义化</strong></p>
<h2 id="新的特殊内容元素"><a href="#新的特殊内容元素" class="headerlink" title="新的特殊内容元素"></a>新的特殊内容元素</h2><pre><code>H5标签在IE8以下有兼容性问题:可以用html5shiv框架去解决;
cc:ie6
用div 还是html5的标签 看你自己 （保证用新的不会有问题）（看同事）
</code></pre><p><strong>结构元素</strong></p>
<pre><code>- header        
- nav 导航链接    
- aside 附属信息    
- section 分块        
- article 文档独立部分    
- footer 
</code></pre><p><strong>分组元素</strong></p>
<pre><code>- figure 和 figcaption
        定义独立的流内容    
- hgroup
        用于将多个标题组成一个标题组, 经常与h1~6组合使用, 放在header中.    
- hgroup 与 figcaption 组合使用
</code></pre><p><strong>页面交互元素</strong></p>
<pre><code>- details 和 summary    
        组合使用,当用户单击summary时,显示或隐藏details    
- progress    
        完成进度条:&lt;progress value=&quot;50&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;    
- meter    
        用于表示指定范围内的数值,进度条
        &lt;meter value=&quot;85&quot; min=&quot;0&quot; max=&quot;100&quot; low=&quot;60&quot; high=&quot;80&quot; title=&quot;65分&quot; optimum=&quot;100&quot;&gt;65分&lt;/meter&gt;
</code></pre><p><strong>文本层次语义元素</strong></p>
<pre><code>- time 定义时间, 没有样式显示, 有助于机器识别 
- mark 高亮显示, 更随意灵活
- cite 引用标记
</code></pre><p><strong>全局属性</strong></p>
<pre><code>- draggable:true/false 定义元素是否可以拖动
- hidden:true/false
- spellcheck:true/false 输入框等拼写检查
- contenteditable 是否可编辑
</code></pre><h2 id="新的表单控件"><a href="#新的表单控件" class="headerlink" title="新的表单控件"></a>新的表单控件</h2><pre><code>键盘适配
- calendar
- date    
- time    
- image: 图像形式的提交按钮     
- email    
- url    
- tel    
- number    
- search
</code></pre><h2 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h2><pre><code>- placeholder    占位符    
- autofocus        自动获得焦点    
- multiple        多文件上传    
- required        必填项    
- pattern        自定义验证
</code></pre><h2 id="用于绘画的canvas元素"><a href="#用于绘画的canvas元素" class="headerlink" title="用于绘画的canvas元素"></a>用于绘画的canvas元素</h2><h2 id="用于媒介回放的video和audio元素"><a href="#用于媒介回放的video和audio元素" class="headerlink" title="用于媒介回放的video和audio元素"></a>用于媒介回放的video和audio元素</h2><p><strong>音频</strong></p>
<pre><code>&lt;audio src=&quot;&quot; controls autoplay loop&quot;&gt;
    &lt;source src=&quot;&quot;&gt;        //    备用格式
    &lt;source src=&quot;&quot;&gt;
&lt;/audio&gt;
</code></pre><p><strong>视频</strong></p>
<pre><code>&lt;video src=&quot;&quot; width=&quot;1000&quot;(占据尺寸拉伸,视频不会被拉伸) height=&quot;200&quot;&gt;
&lt;/video&gt;
</code></pre><p><strong>API</strong>    </p>
<pre><code>方法:    
        load()        // 
        play()        //    播放
        pause()        // 暂停
属性:
        currentSrc    //    获取路径
        currentTime    //    获取播放的时间
        duration    //    媒体总时间
事件:    
        ontimeupdate    //    播放时重复触发    
        onended            //    结束时触发
</code></pre><h2 id="H5-DOM扩展"><a href="#H5-DOM扩展" class="headerlink" title="H5 DOM扩展"></a>H5 DOM扩展</h2><p><strong>获取元素</strong></p>
<pre><code>一般用于移动端(不引用某库的时候):    

document.querySelector(&quot;.item&quot;);    一般用来获取id

document.querySelectorAll(&quot;.item&quot;);
</code></pre><p><strong>事件监听</strong></p>
<pre><code>addEventLinstener(&quot;click&quot;,function,false/true);
</code></pre><p><strong>类名操作</strong></p>
<pre><code>ele.classList    该类名的集合
ele.classList.remove(&apos;active&apos;);        删除
ele.classList.add(&apos;active&apos;);        添加
ele.classList.toggle(&apos;active&apos;);        切换
ele.classList.contains(&apos;active&apos;)    查询:返回boolean值
</code></pre><p><strong>自定义属性</strong>    </p>
<pre><code>用来定义一些和DOM强相关的数据, 一般用在一些JS特效 tab栏 轮播图 
    可以降低DOM之间的关联 降低耦合度
    写法 是data-属性名

&lt;a href=&quot;&quot; data-target=&quot;#target&quot;&gt;

获取自定义属性:
ele.getAttribute(&quot;&quot;);            效率低
ele.dataset[&quot;data-target&quot;];        获取不到/
ele.dataset[&quot;target&quot;];            H5方式, 不需要data-了 效率高

jQuery方法是ele.da
</code></pre><hr>
<p>ta(“”);</p>
<h2 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h2><p><strong>网络状态:</strong></p>
<pre><code>window.online;        网络连接时调用
window.offline;        网络断开时调用
</code></pre><p><strong>全屏:</strong>    </p>
<pre><code>node.requestFullScreen();    开启全屏显示
node.cancelFullScreen();    关闭全屏显示
兼容性问题:
node.webkitRequestFullScreen();
node.webkitCancelFullScreen();
    node.webkitIsFullScreen();

node.mozRequestFullScreen;
node.mozCancelFullScreen;
    node.mozFullScreen();

全屏伪类选择器
:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {}
</code></pre><p><strong>拖拽:</strong>    八大事件 重点(dragstart dragover drop)</p>
<pre><code>拖拽物事件:
&lt;div draggable=&quot;true&quot;&gt;&lt;/div&gt;
div.addEventListener(&quot;drag&quot;,function(){})            拖拽中重复触发
div.addEventListener(&quot;dragstart&quot;,function(){})        开始时触发一次
div.addEventListener(&quot;dragleave&quot;,function(){})        拖拽中鼠标移出原范围是触发;
div.addEventListener(&quot;dragend&quot;,function(){})        结束时触发一次


目标物事件:
target.addEventListenr(&quot;dragenter&quot;,function(){})    鼠标移入目标范围时触发
target.addEventListenr(&quot;dragover&quot;,function(){})        鼠标在目标范围内是重复触发
target.addEventListenr(&quot;dragleave&quot;,function(){})    鼠标离开目标范围时触发一次
target.addEventListenr(&quot;drop&quot;,function(e){            在目标范围内松开鼠标时触发
    不能直接触发, 需要在拖拽过程中阻止拖拽的默认事件.
    e.preventDefault(); // 阻止默认事件
    e.dataTransfer.getData(&apos;Text&apos;);
    e.dataTransfer.getData(&apos;Text/uri-list&apos;);        只能获得图片地址
    do();
})    
div不能直接拖拽:
    1. div添加draggable属性
    2. div.dragstart设置event.dataTransfer.setData(key,div.id);
    3. target.drop事件 
        var id = e.dataTransfer.getData(key); 
        target.appendChild(document.querySelector(id))

    1. div默认不可以拖拽,需要设置draggable=&quot;true&quot;;
    2. 给目标注册drop事件,松开时把div添加到目标物里面
    3. drop事件默认不可触发,需要在dragover中阻止默认行为
    4. div默认不可拖拽,所以dataTransfer里面获取不到div的相关信息
    5. 就需要在div开始拖拽的时候给dataTransfer属性里面设置值(选择器)dataTransfer.setData(key,value);
    6. 在drop事件里面通过getData获取value,根据选择器获取到div元素,然后追加到目标中
</code></pre><p><strong>文件:</strong></p>
<pre><code>1. file 对象 在拖拽文件的时候e.dataTransfer.files[0]; 然后 input:file里面选择的文件也是file对象
2. fileReader实例 var reader = new fileReader(); 
3. 使用reader实例去读取文件 读取的方式有3种;
4. 读取的时候需要添加一个load读取完成事件才能拿到读取的结果 reader.result属性里面

var file = e.dataTransfer.files[0];    // 不加索引时,获得 FileList 文件集合数组对象 可用于多文件事件

FileReader 对象;
var reader = new FileReader;     //    实例化对象;

reader.readAsText(file);        //    读文本
reader.readAsDataURL(file);        //    读文件    需加入到对应标签内;
reader.readAsBinaryString(file);    // 二进制格式

reader.addEventListener(&apos;load&apos;,function(){
    target.innerHTML += reader.result;}
</code></pre><p><strong>地理位置:</strong></p>
<pre><code>1. 什么是地理定位: 就是获取你当前的位置
2. 为什么要学习地理定位: 可以做一些地图,或者购物设置收获地址,天气等等需要地址的地方等等
3. 如何学习地理定位:
    1. 获取当前位置API
        - navigator.geolocation.getCurrentPosition(callback)
        - 成功获取地理信息后,会调用successCallback,并返回包含位置信息的对象.
    2. 重复获取当前位置
        - navigator.geolocation.watchPosition(callback)
    3. 事件对象position对象
        - position.coords.latitude 纬度
        - position.coords.longitude 经度
4. 总结: 应用在一些地图 ,导航 天气等等一些地方 ,可以搭配百度地图做出很多功能

百度地图API:
var map = new BMap(&apos;allmap&apos;);    // 创建Map实例
map.centerAndZoom(new BMap.Point(113.90,22.57),20);    // 初始化地图
map.addControl(new BMap.MapTypeControl());            // 添加地图类型控件
map.setCurrentCity(city);                            // 设置地图显示的城市,必须
map.enableScrollWheelZoom(true);                    // 开启鼠标滚轮缩放

navigator.geolocation.watchPosition(successCallback,errorCallback,options)
成功获取地理信息后,会调用successCallback,并返回包含位置信息的对象.
</code></pre><p><strong>离线存储:</strong></p>
<pre><code>1. 什么是web存储: localStorage 本地存储 ,sessionStorage 会话存储
    可以存储一些网页上需要的数据
2. 为什么要学习web存储: 可以用来存储网页上的数据 要用到的时候直接渲染到页面上 提升网站性能,做到一些缓存的效果

3. 以后开发中一般用来存储一些不是很重要的用户信息,或者一些网站里面比较固定的内容 方便后续网站打开的速度,减轻服务器压力

永久存储:localStorage: 20M
window.localStorage.setItem(key,value);
window.localStorage.getItem(key);
window.localStorage.removeItem(key);
window.localStorage.clear();

临时存储session:        5M        关闭浏览器清除
window.sessionStorage.setItem(key,value);
window.sessionStorage.getItem(key);
window.sessionStorage.removeItem(key);
window.sessionStorage.clear();
</code></pre><p><strong>appCache 应用缓存</strong></p>
<pre><code>H5中我们可以轻松构建一个离线应用,只需要创建一个cache manifest文件
应用缓存: 就是可以实现无网络状态访问一个应用或者一个网站
优势:
    1. 可配置需要缓存的资源
    2. 网络无连接时应用仍可用
    3. 本地读取缓存资源,提升访问速度,增强用户体验
    4. 减少请求,缓解服务器负担

编写:
1. 设置缓存清单文件
    1. 在页面的html 节点添加&lt;html lang=&quot;en&quot; manifest=&quot;cache.manifest&quot;&gt; 保证文件在网页的旁边
2. manifest文件格式
    1. 顶部写 CACHE MANIFEST
    2. version: 1.0.0 指定缓存的版本 一旦版本更改了浏览器可以重新缓存 ,可以实现缓存的同步更新
    3. CACHE: 换行 tab 指定需要缓存的静态资源 如.css .js .html等
    4. NETWORK: 换行 tab 指定需要在线访问的资源 ,可使用通配符 * 等等
    5. FALLBACK: 换行 tab 当被缓存的文件找不到的备用资源

        CACHE MANIFEST

        # 注释内容

        version: 1.0.3
        # CACHE: 一定要记得带:冒号
        CACHE:
            index.html
            css/style.css
            js/index.js
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5-标签/">html5 标签</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2015/12/05/h5总结/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="h5总结">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-css3入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/css3入门/" class="article-date">
  	<time datetime="2015-12-05T05:45:04.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/css3入门/">
        css3入门
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><pre><code>浏览器支持程度差, 移动端支持优于PC端
考虑用户群体, 遵照产品方案
</code></pre><p><strong>浏览器兼容:</strong></p>
<pre><code>-webkit-:Safari and Chrome 兼容前缀
-ms-:IE9
-moz-:Firefox
-o-:Opera

通过    http://caniuse.com/    可查询各特性的支持程度, 一般兼容性处理的方法是添加私有前缀, 如不能解决, 应避免使用, 无需刻意去处理css3的兼容性问题.
</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><pre><code>- (E)[att]            存在该属性即可            
- (E)[att=value]        属性值完全等于value
- (E)[att^=value]    
    p[id^=&quot;one&quot;] id包含前缀为one的元素

- (E)[att$=value]
    p[id$=&quot;one&quot;] id包含后缀为one的元素

- (E)[att~=value]
    p[id~=&quot;one&quot;] id属性值为多个,其中一个等于one的元素

- (E)[att*=value]    
    p[id*=&quot;one&quot;] id包含one的元素

- (E)[att|=value]    
    p[id|=&quot;one&quot;] id包含以one开头,并用连字符&apos;-&apos;分隔的元素,如果仅为one,也会被选中
</code></pre><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><pre><code>- 子代选择器 
    p -  span 选择第一级子元素

- 兄弟选择器
    + 临近兄弟选择器
    ~ 普通兄弟选择器

- 结构化伪类选择器
    :root                     匹配文档根元素
    :only-child 
    :first-child 
    :last-child 
    :nth-child(2n+1) 
    :nth-last-child(n) 
    :nth-of-type(n) 
    :nth-last-of-type(n) 

    :empty 
    :target                 用于为页面中的某个target元素指定样式(该元素的id被当做页面中的超链接使用)        
    :not                     排除特定子元素
</code></pre><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><pre><code>::before         指定元素之前插入内容
::after         指定元素之后插入内容
::first-letter    文本的第一个单词或字（如中文、日文、韩文等）
::first-line     文本第一行
::selection     可改变选中文本的样式
</code></pre><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><pre><code>RGBA:

HSLA:    Hue Saturation Lightness Alpha
    H 色调 取值范围0~360，0/360表示红色、120表示绿色、240表示蓝色
    S 饱和度 取值范围0%~100%
    L 亮度 取值范围0%~100%
    A 透明度 取值范围0~1
在进行近似色变换的时候, HSLA比rgba好用的多

transparent:完全透明;
</code></pre><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><pre><code>- box-sizing:content-box;  width = content  
- box-sizing:border-box;   width = border + padding + content
</code></pre><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><p><strong>阴影</strong><br>    text-shadow:none | <shadow> [ , <shadow> ]*<br>        <shadow> = <length>{2,3} &amp;&amp; <color>?<br>        <length>①： 第1个长度值用来设置对象的阴影水平偏移值。可以为负值<br>        <length>②： 第2个长度值用来设置对象的阴影垂直偏移值。可以为负值<br>        <length>③： 如果提供了第3个长度值则用来设置对象的阴影模糊值。不允许负值<br>        <color>： 设置对象的阴影的颜色。 </color></length></length></length></color></length></shadow></shadow></shadow></p>
<pre><code>demo{    // 火焰文字效果
    font:bold 100px/1.5 arial,sans-serif;
    text-shadow:0 0 5px #fff,
    0 0 20px #fefcc9,
    10px -10px 30px #feec85,
    -20px -20px 40px #ffae34,
    20px -40px 50px #ec760c,
    -20px -60px 60px #cd4606,
    0 -80px 70px #973716,
    10px -90px 80px #451b0e;
}
demo{    //    霓虹效果
    font:bold 100px/1.5 georgia,sans-serif;
    text-shadow:0 0 10px #fff, 
    0 0 20px #fff,
    0 0 30px #fff,
    0 0 40px #ff00de,
    0 0 70px #ff00de,
    0 0 80px #ff00de,
    0 0 100px #ff00de,
    0 0 150px #ff00de;
}
</code></pre><p><strong>排版</strong></p>
<pre><code>word-wrap
    normal： 允许内容顶开或溢出指定的容器边界。 
    break-word： 内容将在边界内换行。如果需要，单词内部允许断行。 

word-break：normal | keep-all | break-all
    normal： 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 
    keep-all： 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 
    break-all： 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。

word-spacing：normal | &lt;length&gt; | &lt;percentage&gt;    
        检索或设置对象中的单词之间的最小，最大和最佳间隙。

writing-mode: horizontal-tb | vertical-rl | vertical-lr 
    此属性效果不能被累加使用。例如，父对象的此属性值设为 tb-rl ，子对象再设置该属性将不起作用，仍应用父对象的设置。

white-space：normal | pre | nowrap | pre-wrap | pre-line
    normal： 默认处理方式。 
    pre： 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行。可查阅pre对象 
    nowrap： 强制在同一行内显示所有文本，合并文本间的多余空白，直到文本结束或者遭遇br对象。 
    pre-wrap： 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。 
    pre-line： 保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。 
</code></pre><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><strong>圆角边框</strong>        </p>
<pre><code>border-radius:圆角边框:border-radius: 100px 25px 80px 5px / 45px 25px 30px 15px;;
    border-radius还可以用斜杠设置第二组值。这时，第一组值表示水平半径，第二组值表示垂直半径。第二组值也可以同时设置1到4个值，应用规则与第一组值相同。
</code></pre><p><strong>边框图片</strong></p>
<pre><code>移动端自适应高度的背景:
border-image-source:url();
border-image-width:一般设置为原始边框宽度;
border-image-slice:上下左右,可简写,fill;    fill中间填充;
border-image-repeat:stretch;

border-image-ouset:0px;            扩展,一般不用
</code></pre><h4 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h4><pre><code>box-shadow:5px 5px 10px 2px #999 insert,-5px -5px 10px 2px #333;
box-shadow: -15px -15px(方向和距离) 10px(模糊半径) 3px(大小变化) #f00 inset;
    &lt;length&gt;①： 第1个长度值用来设置对象的阴影水平偏移值。可以 为负值 
    &lt;length&gt;②： 第2个长度值用来设置对象的阴影垂直偏移值。可以 为负值 
    &lt;length&gt;③： 如果提供了第3个长度值则用来设置对象的阴影模糊值。不允许 负值 
    &lt;length&gt;④： 如果提供了第4个长度值则用来设置对象的阴影外延值。可以 为负值 
    &lt;color&gt;： 设置对象的阴影的颜色。默认为黑色 
    inset： 设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影 

.cloudy {    //    双子
    background: #60768D;
    height: 1rem;
    width: 1rem;
    border-radius: 50%;
    box-shadow: 1rem 0.2rem 0 -0.1rem;

    position: absolute;
    left: .5rem;
    top: 1.8rem;
    z-index: 5;
}
</code></pre><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>- 背景定位原点:
- background-position:x y;

- 背景是否可以滚动:
- background-attachment:scroll/fixed;

- 背景图尺寸:
- background-size:x y;
- background-size:cover / contain ;         更常用

- 背景定位原点:
- background-origin:padding-box/border-box/content-box;

- 背景裁切:
- background-clip:padding-box/border-box/content-box;
    背景定位原点设为padding-box 裁切设为padding-box, 实现移动端按钮精灵图背景居中显示(提升交互体验)
    对比clip:rect
        clip:rect(t r b l)
        rect(30px 200px 200px 20px)

- 多重背景:
- background-img:url()*3;background-position:a,b,c;

- 复合属性:
background:color,image,repeat,attachment,position,size,clip,origin;
</code></pre><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p><strong>线性渐变</strong></p>
<pre><code>- background-image: linear-gradient(to right,green,blue,red);
- 角度:正上方是0deg
- background-image: linear-gradient(135deg,green,blue,red);

- background-image: linear-gradient(135deg,green 30%,blue 80%,red);
</code></pre><p><strong>径向渐变</strong></p>
<pre><code>- 眼睛:background-image: radial-gradient(circle at 150px 50px,#ddd 1%,#000 3% );

    &lt;extent-keyword&gt; circle | ellipse 都接受该值作为 size
    closest-side： 指定径向渐变的半径长度为从圆心到离圆心最近的边 
    closest-corner： 指定径向渐变的半径长度为从圆心到离圆心最近的角 
    farthest-side： 指定径向渐变的半径长度为从圆心到离圆心最远的边 
    farthest-corner： 指定径向渐变的半径长度为从圆心到离圆心最远的角 
</code></pre><p><strong>重复渐变</strong></p>
<pre><code>- background-image: repeating-linear-gradient(to right,green,blue 10%,red 30%);

- background-image: repeating-radial-gradient(circle at center,#ddd,#00f 50%,#000 10%);
</code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p><strong>过渡</strong></p>
<pre><code>- transition-property:none/all(所有属性都过渡)/property(定义某些css属性,逗号分隔);            //    无继承性

- transition-duration:time;

- transition-delay:time;        //可为负值, 表示前面的时间忽略

- transition-timing-function:(速度曲线);

- transition:property duration timing-function delay;
</code></pre><p><strong>变形</strong></p>
<pre><code>2D变换

    任何非none值的transform会导致创建一个堆栈上下文和包含块。
    如果父级元素设置了transform属性，position:relative/absolute/fixed会基于此定位

- transform:none/transform-functions;

-matrix(a,b,c,d,e,f)        矩形变换,定位

-translate(x,y)            移动
-scale(x,y)                缩放
-rotate(xdeg)            旋转
-skew(x,y)                倾斜 角度值 

- transform-origin:x y;变换中心点;

3D变换

    perspective和preserve-3d都不可继承. 只对一级子元素作用.
    只设置transform-style，不设置perspective，三维变换的子元素不能形成透视，在平面被挤压，此时加上transform属性之后, 创建了新的堆栈空间. 就可以了

透视    perspective: 定义 3D 元素距视图的距离，以像素计，用于设置透视/景深效果。
    1. 作为一个属性，设置给父元素，作用于所有3D转换的子元素
    2. 作为transform属性的一个值，做用于元素自身 
            1. perspective 属性只影响 3D 转换元素。
            2. perspective取值为none或不设置，就没有真3D空间。
            3. perspective取值越小，3D效果就越明显，也就是你的眼睛越靠近真3D。
            4. perspective的值无穷大，或值为0时与取值为none效果一样。

    3D呈现（transform-style） 给父级元素添加, 不能继承

    设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为变形原素。

        flat：所有子元素在 2D 平面呈现
        preserve-3d：保留3D空间

backface-visibility: 设置元素背面是否可见

参考文档
http://isux.tencent.com/css3/index.html?transform
CSS3动画库
animate.css
</code></pre><p><strong>动画</strong></p>
<pre><code>关键帧@keyframes;
@keyframes animationname {
    keyframes-selector{css-styles;}    
}

@keyframes &apos;appeardisapper&apos; {
    from,to{opacity:0;}
    20%,80%{opacity:1}
}

- animation-name

- animation-duration

- animation-timing-fuction

- animation-delay

- animation-itration-count:number/infinite;

- animation-direction:normal/alternate                交错进行:摆钟

- animation-play-state  播放状态, running paused        js控制

- animation-fill-mode  执行开始/完毕后状态 backwards / forwards较多

- steps(60) 分为60步完成

复合属性:animation:name,duration,timing-function,delay,itration-count,direction
</code></pre><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><pre><code>column-count:
column-gap:
column-rule:1px solid #ccc;

column-width:
        如果与分列默认宽度不一致,则尽量补充长度
        列宽大于默认,以设置的为基准,但是自动伸缩来填满页面;
        列宽小于默认,以默认的为准.
        没鸟用.
column-span:1/all;    用于标题跨列

如果设置了高度,将会影响盒子列数:小于默认高度,分更多栏;大于不影响列数;

对比表格:colspan,rowspan;
</code></pre><h3 id="伸缩布局"><a href="#伸缩布局" class="headerlink" title="伸缩布局"></a>伸缩布局</h3><pre><code>Flex是Flexible Box的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。

采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。
</code></pre><p><img src="http://i.imgur.com/IJ6c5Vd.png" alt="盒子图解"></p>
<pre><code>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。

项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。
</code></pre><p><strong>容器的属性</strong></p>
<pre><code>以下6个属性设置在容器上。

1. flex-direction     属性决定主轴的方向（即项目的排列方向）。
        flex-direction: row | row-reverse | column | column-reverse;

2. flex-wrap        定义如何换行
        flex-wrap: nowrap | wrap | wrap-reverse;

3. flex-flow        **上面两个的简写方式**

4. justify-content    属性定义了项目在主轴上的对齐方式。
        justify-content: flex-start | flex-end | center | space-between | space-around;

5. align-items    属性定义项目在交叉轴上如何对齐。
        align-items: flex-start | flex-end | center | baseline | stretch;

6. align-content        属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
        align-content: flex-start | flex-end | center | space-between | space-around | stretch;
</code></pre><p><a href="http://i.imgur.com/vZJdk7F.png" target="_blank" rel="external">图解</a>    </p>
<p><strong>项目的属性</strong></p>
<pre><code>以下6个属性设置在项目上。

1. order        属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        order: &lt;integer&gt;;    /* default 0 */

2. flex-grow        属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        flex-grow: &lt;number&gt;; /* default 0 */

3. flex-shrink    属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        flex-shrink: &lt;number&gt;; /* default 1 */

4. flex-basis    属性定义了在分配多余空间之前，项目占据的基础尺寸, 它的默认值为auto，即项目的本来大小。
        flex-basis: &lt;length&gt; | auto; /* default auto */

5. flex    **属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。**

6. align-self    单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto
         align-self: auto | flex-start | flex-end | center | baseline | stretch;
</code></pre><h3 id="Web字体"><a href="#Web字体" class="headerlink" title="Web字体"></a>Web字体</h3><p><strong>字体格式</strong></p>
<pre><code>- @font-face;定义服务器字体:

    @font-face {
        font-family;xxx;
        src:xxx;
    }

- word-wrap;实现长单词和url在容器内的自动换行;    
- text-shadow:h- v- blur color,第二组参数,...;

不同浏览器所支持的字体格式是不一样的:
1. TureType(.ttf)格式
        .ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；

2. OpenType(.otf)格式
        .otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；

3. Web Open Font Format(.woff)格式
        woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；

4. Embedded Open Type(.eot)格式
        .eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；

5. SVG(.svg)格式
        .svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；

    了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。

推荐http://www.zhaozi.cn/、http://www.youziku.com/ 查找更多中文字体
</code></pre><p><strong>字体图标</strong></p>
<pre><code>其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？
答案是肯定的。

常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体包，然后就可以像使用文字一样使用图标了。

主体元素添加两个类名, (字体类名 + 图标类名)
通过伪元素的方式添加图标. content = &apos;\eabd&apos;; 内容需加斜杠

优点：
    1、将所有图标打包成字体库，减少请求；
    2、具有矢量性，可保证清晰度；
    3、使用灵活，便于维护；

Font Awesome 使用介绍
    http://fontawesome.dashgame.com/

定制自已的字体图标库
    http://iconfont.cn/
    https://icomoon.io/

SVG素材
    http://www.iconsvg.com/
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c33-动画-样式/">c33 动画  样式</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2015/12/05/css3入门/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="css3入门">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-DOM事件操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/05/DOM事件操作/" class="article-date">
  	<time datetime="2015-06-05T02:53:19.000Z" itemprop="datePublished">2015-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/05/DOM事件操作/">
        js事件操作
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Window事件"><a href="#Window事件" class="headerlink" title="Window事件"></a>Window事件</h3><pre><code>onload               页面加载完毕的事件
onscroll            页面滚动时候触发的事件
onresize            页面大小改变的时候时候触发的事件
</code></pre><p><strong>DOM Ready</strong><br>    在页面的DOM树创建完成后(也就是HTML解析第一步完成)即触发,而无需等待其他资源的加载.</p>
<pre><code>浏览器渲染引擎的基本渲染流程:

    1. 解析HTML,构建DOM树(构建DOM节点);
    2. 构建渲染树(解析样式信息);
    3. 布局渲染树(布局DOM节点);        
    4. 绘制渲染树(绘制DOM节点);

DOMContentLoaded
    - 支持DOMContentLoaded事件的, 就用该事件
    - 不支持的, 就用著名的Hack兼容方式, 原理通过IE中的document.documentElement.doScroll(&quot;left&quot;)来判断DOM数是否创建完毕
    - 摘自DOM事件探秘-慕课网
</code></pre><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><pre><code>onclick                鼠标的单击事件
ondblclick            鼠标的双击事件
onmouseup            鼠标的弹起事件

onmouseover            鼠标移入的事件
onmousemove            鼠标移动的事件
onmouseout            鼠标移出的事件

onkeydown            键盘上的按键按下的时候就会触发                一般输入框和文本框使用
onkeyup                键盘上的按键按下,并抬起来的时候才会触发        一般输入框和文本框使用

onfocus                获得焦点的事件
onblur                失去焦点的事件
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1. 事件源         x盒子
2. 事件             点击
3. 事件处理程序     关闭广告

事件源.事件 = function() {事件处理函数}

书写事件位置:

1. 行内    标签里面
2. 内嵌    script里面    函数调用等
</code></pre><h4 id="注册事件方式"><a href="#注册事件方式" class="headerlink" title="注册事件方式"></a>注册事件方式</h4><p><strong>On</strong>的方式只能对同一标签对象注册一个事件，如果注册多个，后面的会覆盖前面的事件，<br>如果想对某个标签对象注册多个事件的话，可以用<strong>addEventListener</strong></p>
<p>obj.addEventListener(type,listener,false); false为支持冒泡;</p>
<pre><code>但是IE8及之前的浏览器仅支持attachEvent
</code></pre><p>obj.attachEvent(“on”+type,listener); 需加”on”;</p>
<pre><code>/**
 * 封装了兼容版本的注册事件的方法
 * @param element
 * @param type
 * @param listener
 */
function addEventLister(element,type,listener){
    // 能力检测
    if(element.addEventListener){
        element.addEventListener(type,listener,false);

    }else if(element.attachEvent){
        element.attachEvent(&quot;on&quot;+type,listener);

    }else {
        element[&quot;on&quot;+type] = listener;
    }
}
</code></pre><p><strong>事件冒泡</strong></p>
<pre><code>当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。
这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。

事件委托:
应用:本来该自己做的事情,我们可以让另一个对象(父级对象)帮我们做.
    比如:在点击任何子元素,都要触发同样事件的情况下,就可以给父级设置事件!    

E 6.0: 
div -&gt; body -&gt; html -&gt; document
其他浏览器: 
div -&gt; body -&gt; html -&gt; document -&gt; window

以下事件不冒泡：blur、focus、load、unload

阻止冒泡的方法
    w3c的方法是event.stopPropagation() 
    IE则是使用event.cancelBubble = true 
    兼容:
        if(event &amp;&amp; event.stopPropagation) {         
          event.stopPropagation();  //  w3c 标准
          } else {
          event.cancelBubble = true;  // ie 678  ie浏览器
        }
</code></pre><p><strong>事件对象 (event)</strong></p>
<pre><code>src.onclick = function(event) {}
在触发事件的时候, 会产生一个事件对象event, 这个对象中包含着所有与事件相关的信息. 所有浏览器都支持event对象, 但方式不同.

IE8以下问题：
1. attach回调函数this指向window，可以通过event获得事件对象
2. on添加事件时，回调中this指向undefined；需通过window.event获得

比如鼠标操作的时候, 会添加鼠标位置的相关信息到event中.

兼容处理:var event = event || window.event;
</code></pre><p><strong>event 常见属性</strong></p>
<pre><code>- 属性        作用

- clientX    光标相对与可视区域基准点(固定定位)的位置    
- clientY    光标相对与可视区域基准点(固定定位)的位置    

- data    返回拖拽对象的URL字符串（dragDrop）
- width    该窗口或框架的高度
- height    该窗口或框架的高度

- pageX    光标相对与文档基准点(绝对定位)的位置（ie无）
- pageY    光标相对与文档基准点(绝对定位)的位置（ie无）
    兼容:
    - var pageX = event.pageX || event.clientX + document.documentElement.scrollLeft;
    - var pageY = event.pageY || event.clientY+document.documentElement.scrollTop;

- screenX    光标相对于该屏幕的水平位置
- screenY    光标相对于该屏幕的垂直位置

- target    该事件被传送到的对象
    - target = event.target || event.srcElement;
    - 兼容性: targetId=event.target ? event.target.id : event.srcElement.id;

- currentTarget 当前执行阶段的对象
- eventPhase        判断当前对象处于哪个执行阶段    

- type    事件的类型 click/move/over等
- preventDefault        阻止默认行为 IE: event.returnValue = false;
</code></pre><p><strong>防止拖动选择</strong></p>
<pre><code>正常时按下鼠标然后拖拽可以选择文字的。 
解决方式:清除选中的内容 
window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
</code></pre><p><strong>计时器</strong></p>
<pre><code>Js是单线程执行的,某一段代码执行的时候,所有后续的任务必须等待,形成一个队列,常称为&quot;阻塞式执行&quot;.
计时器是在合适的时间将代码插入队列,但不保证执行.

var that = this; 经常用到

setTimeout(function,delay); 返回数字
    延迟执行,

setInterval(function,delay);
    循环执行,

clearTimeout(num);
clearInterval(num);

seInterval是排队执行的

    假如 间隔时间是1秒, 而执行的程序时间是2秒 上次没有执行完的代码会排队,上一次执行完下一次就立即执行,这样实际执行间隔时间为2秒.

setTimeout 延迟时间为1秒执行,要执行的代码需要2秒来执行,那这段代码上一次与下一次的执行时间为3秒.

定时器特殊:
    setTimeout(goIndexPage,1000);
    var count = 5;
    demo.innerHTML = &quot;&lt;a href=&apos;http://www..&apos;&gt;本页面将在&quot;+count+&quot;秒钟之后跳转页面&lt;/a&gt;&quot;;

    递归方式避免setInterval的时间混乱
    function goIndexPage() {
        count--;
        if(count&lt;=0) {
            window.location.href=&quot;&quot;;
        }else{
            setTimeout(goIndexPage,1000);
            setTimeout(arguments.callee,1000); 更直接更好
        }
    }

alert(1);
setTimeout(&quot;alert(2)&quot;,0);
alert(3);
1 3 2; 单线程 阻塞式 插入队列,但不保证执行.

缓动动画:step = (target - leader)/10;
        step = step&gt;0 ? Math.ceil(step) : Math.floor(step);
        leader += step;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-javascript-事件/">js javascript 事件</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2015/06/05/DOM事件操作/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="js事件操作">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 lhl
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>